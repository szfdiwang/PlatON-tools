{"version":3,"file":"platon-tools.umd.js","sources":["../node_modules/@ethereumjs/rlp/dist/esm/index.js","../src/index.ts"],"sourcesContent":["/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/\nexport function encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        let outputLength = 0;\n        for (let i = 0; i < input.length; i++) {\n            const encoded = encode(input[i]);\n            output.push(encoded);\n            outputLength += encoded.length;\n        }\n        return concatBytes(encodeLength(outputLength, 192), ...output);\n    }\n    const inputBuf = toBytes(input);\n    if (inputBuf.length === 1 && inputBuf[0] < 128) {\n        return inputBuf;\n    }\n    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);\n}\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */\nfunction safeSlice(input, start, end) {\n    if (end > input.length) {\n        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');\n    }\n    return input.slice(start, end);\n}\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */\nfunction decodeLength(v) {\n    if (v[0] === 0) {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseHexByte(bytesToHex(v));\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Uint8Array.from([len + offset]);\n    }\n    const hexLength = numberToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = numberToHex(offset + 55 + lLength);\n    return Uint8Array.from(hexToBytes(firstByte + hexLength));\n}\nexport function decode(input, stream = false) {\n    if (typeof input === 'undefined' || input === null || input.length === 0) {\n        return Uint8Array.from([]);\n    }\n    const inputBytes = toBytes(input);\n    const decoded = _decode(inputBytes);\n    if (stream) {\n        return {\n            data: decoded.data,\n            remainder: decoded.remainder.slice(),\n        };\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error('invalid RLP: remainder must be zero');\n    }\n    return decoded.data;\n}\n/** Decode an input with RLP */\nfunction _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.subarray(1),\n        };\n    }\n    else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Uint8Array.from([]);\n        }\n        else {\n            data = safeSlice(input, 1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');\n        }\n        return {\n            data,\n            remainder: input.subarray(length),\n        };\n    }\n    else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error('invalid RLP: not enough bytes for string length');\n        }\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length <= 55) {\n            throw new Error('invalid RLP: expected string length to be greater than 55');\n        }\n        data = safeSlice(input, llength, length + llength);\n        return {\n            data,\n            remainder: input.subarray(length + llength),\n        };\n    }\n    else if (firstByte <= 0xf7) {\n        // a list between 0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = safeSlice(input, 1, length);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.subarray(length),\n        };\n    }\n    else {\n        // a list over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length < 56) {\n            throw new Error('invalid RLP: encoded list too short');\n        }\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error('invalid RLP: total length is larger than the data');\n        }\n        innerRemainder = safeSlice(input, llength, totalLength);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.subarray(totalLength),\n        };\n    }\n}\nconst cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    // Pre-caching chars with `cachedHexes` speeds this up 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += cachedHexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction parseHexByte(hexByte) {\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte))\n        throw new Error('Invalid byte sequence');\n    return byte;\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = parseHexByte(hex.slice(j, j + 2));\n    }\n    return array;\n}\n/** Concatenates two Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction utf8ToBytes(utf) {\n    return new TextEncoder().encode(utf);\n}\n/** Transform an integer into its hexadecimal value */\nfunction numberToHex(integer) {\n    if (integer < 0) {\n        throw new Error('Invalid integer as argument, must be unsigned!');\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n    return str.length >= 2 && str[0] === '0' && str[1] === 'x';\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform anything into a Uint8Array */\nfunction toBytes(v) {\n    if (v instanceof Uint8Array) {\n        return v;\n    }\n    if (typeof v === 'string') {\n        if (isHexPrefixed(v)) {\n            return hexToBytes(padToEven(stripHexPrefix(v)));\n        }\n        return utf8ToBytes(v);\n    }\n    if (typeof v === 'number' || typeof v === 'bigint') {\n        if (!v) {\n            return Uint8Array.from([]);\n        }\n        return hexToBytes(numberToHex(v));\n    }\n    if (v === null || v === undefined) {\n        return Uint8Array.from([]);\n    }\n    throw new Error('toBytes: received unsupported type ' + typeof v);\n}\nexport const utils = {\n    bytesToHex,\n    concatBytes,\n    hexToBytes,\n    utf8ToBytes,\n};\nexport const RLP = { encode, decode };\n//# sourceMappingURL=index.js.map","import { RLP, utils } from \"@ethereumjs/rlp\";\r\nimport {\r\n  ParamsForCode,\r\n  ParamsForTx,\r\n  CodeType,\r\n  GetDataParams,\r\n  MethodParams,\r\n} from \"./types\";\r\n/**\r\n * @param code number function type E.g. 1004 委托, 1005 解委托\r\n * @returns build-in contract address\r\n */\r\nconst getContractAddress = (code: CodeType): string | undefined => {\r\n  try {\r\n    if (!code || isNaN(code)) throw new Error(\"Please check the parameters\");\r\n\r\n    if (code >= 1000 && code < 2000)\r\n      return \"0x1000000000000000000000000000000000000002\";\r\n    if (code >= 2000 && code < 3000)\r\n      return \"0x1000000000000000000000000000000000000005\";\r\n    if (code >= 3000 && code < 4000)\r\n      return \"0x1000000000000000000000000000000000000004\";\r\n    if (code >= 4000 && code < 5000)\r\n      return \"0x1000000000000000000000000000000000000001\";\r\n    if (code >= 5000 && code < 6000)\r\n      return \"0x1000000000000000000000000000000000000006\";\r\n    else throw new Error(\"The contract corresponding to code cannot be found\");\r\n  } catch (error) {\r\n    console.error(\"error:\", error);\r\n  }\r\n};\r\n\r\nconst _getData = <T extends CodeType>(params: GetDataParams<T>): string => {\r\n  const arr = [];\r\n  for (const param of params) {\r\n    arr.push(\"0x\" + utils.bytesToHex(RLP.encode(param)));\r\n  }\r\n  const rlpedData = \"0x\" + utils.bytesToHex(RLP.encode(arr));\r\n  return rlpedData;\r\n};\r\n\r\n/**\r\n *\r\n * @param code string function type\r\n * @param address string user wallet address\r\n * @param params array E.g. [type, nodeId, amount]\r\n * type uint16(2bytes)\t表示使用账户自由金额还是账户的锁仓金额做委托，0: 自由金额； 1: 锁仓金额；2: 优先使用锁仓余额，锁仓余额不足则剩下的部分使用自由金额\r\n * nodeId nodeId\t64bytes\t被质押的节点的 NodeId\r\n * amount big.Int(bytes)\t委托的金额(按照最小单位算，1LAT = 10^18 von)\r\n * @returns ParamsForTx | undefined\r\n */\r\n\r\nconst getParams = <T extends CodeType>(\r\n  code: T,\r\n  address: string,\r\n  params: ParamsForCode<T>\r\n): ParamsForTx | undefined => {\r\n  try {\r\n    if (!address || !params || params.length === 0)\r\n      throw new Error(\"Function params error\");\r\n    return {\r\n      from: address,\r\n      to: getContractAddress(code),\r\n      data: _getData([code, ...params]),\r\n    };\r\n  } catch (error) {\r\n    console.error(\"error:\", error);\r\n  }\r\n};\r\n\r\nconst Tools = {\r\n  getContractAddress,\r\n  getParams,\r\n};\r\n\r\nexport default Tools;\r\n"],"names":["encode","input","output","outputLength","i","encoded","concatBytes","encodeLength","inputBuf","toBytes","safeSlice","start","end","decodeLength","v","parseHexByte","bytesToHex","len","offset","hexLength","numberToHex","lLength","firstByte","hexToBytes","decode","stream","inputBytes","decoded","_decode","length","llength","data","innerRemainder","d","totalLength","cachedHexes","_v","uint8a","hex","hexByte","byte","array","j","arrays","a","arr","result","pad","utf8ToBytes","utf","integer","padToEven","isHexPrefixed","str","stripHexPrefix","utils","RLP","getContractAddress","code","error","_getData","params","param","address"],"mappings":"gOAOO,SAASA,EAAOC,EAAO,CAC1B,GAAI,MAAM,QAAQA,CAAK,EAAG,CACtB,MAAMC,EAAS,CAAE,EACjB,IAAIC,EAAe,EACnB,QAASC,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAAK,CACnC,MAAMC,EAAUL,EAAOC,EAAMG,CAAC,CAAC,EAC/BF,EAAO,KAAKG,CAAO,EACnBF,GAAgBE,EAAQ,MACpC,CACQ,OAAOC,EAAYC,EAAaJ,EAAc,GAAG,EAAG,GAAGD,CAAM,CACrE,CACI,MAAMM,EAAWC,EAAQR,CAAK,EAC9B,OAAIO,EAAS,SAAW,GAAKA,EAAS,CAAC,EAAI,IAChCA,EAEJF,EAAYC,EAAaC,EAAS,OAAQ,GAAG,EAAGA,CAAQ,CACnE,CAQA,SAASE,EAAUT,EAAOU,EAAOC,EAAK,CAClC,GAAIA,EAAMX,EAAM,OACZ,MAAM,IAAI,MAAM,gEAAgE,EAEpF,OAAOA,EAAM,MAAMU,EAAOC,CAAG,CACjC,CAKA,SAASC,EAAaC,EAAG,CACrB,GAAIA,EAAE,CAAC,IAAM,EACT,MAAM,IAAI,MAAM,0BAA0B,EAE9C,OAAOC,EAAaC,EAAWF,CAAC,CAAC,CACrC,CACA,SAASP,EAAaU,EAAKC,EAAQ,CAC/B,GAAID,EAAM,GACN,OAAO,WAAW,KAAK,CAACA,EAAMC,CAAM,CAAC,EAEzC,MAAMC,EAAYC,EAAYH,CAAG,EAC3BI,EAAUF,EAAU,OAAS,EAC7BG,EAAYF,EAAYF,EAAS,GAAKG,CAAO,EACnD,OAAO,WAAW,KAAKE,EAAWD,EAAYH,CAAS,CAAC,CAC5D,CACO,SAASK,EAAOvB,EAAOwB,EAAS,GAAO,CAC1C,GAAI,OAAOxB,EAAU,KAAeA,IAAU,MAAQA,EAAM,SAAW,EACnE,OAAO,WAAW,KAAK,EAAE,EAE7B,MAAMyB,EAAajB,EAAQR,CAAK,EAC1B0B,EAAUC,EAAQF,CAAU,EAClC,GAAID,EACA,MAAO,CACH,KAAME,EAAQ,KACd,UAAWA,EAAQ,UAAU,MAAO,CACvC,EAEL,GAAIA,EAAQ,UAAU,SAAW,EAC7B,MAAM,IAAI,MAAM,qCAAqC,EAEzD,OAAOA,EAAQ,IACnB,CAEA,SAASC,EAAQ3B,EAAO,CACpB,IAAI4B,EAAQC,EAASC,EAAMC,EAAgBC,EAC3C,MAAMN,EAAU,CAAE,EACZL,EAAYrB,EAAM,CAAC,EACzB,GAAIqB,GAAa,IAEb,MAAO,CACH,KAAMrB,EAAM,MAAM,EAAG,CAAC,EACtB,UAAWA,EAAM,SAAS,CAAC,CAC9B,EAEA,GAAIqB,GAAa,IAAM,CAWxB,GARAO,EAASP,EAAY,IAEjBA,IAAc,IACdS,EAAO,WAAW,KAAK,EAAE,EAGzBA,EAAOrB,EAAUT,EAAO,EAAG4B,CAAM,EAEjCA,IAAW,GAAKE,EAAK,CAAC,EAAI,IAC1B,MAAM,IAAI,MAAM,2EAA2E,EAE/F,MAAO,CACH,KAAAA,EACA,UAAW9B,EAAM,SAAS4B,CAAM,CACnC,CACT,SACaP,GAAa,IAAM,CAIxB,GADAQ,EAAUR,EAAY,IAClBrB,EAAM,OAAS,EAAI6B,EACnB,MAAM,IAAI,MAAM,iDAAiD,EAGrE,GADAD,EAAShB,EAAaH,EAAUT,EAAO,EAAG6B,CAAO,CAAC,EAC9CD,GAAU,GACV,MAAM,IAAI,MAAM,2DAA2D,EAE/E,OAAAE,EAAOrB,EAAUT,EAAO6B,EAASD,EAASC,CAAO,EAC1C,CACH,KAAAC,EACA,UAAW9B,EAAM,SAAS4B,EAASC,CAAO,CAC7C,CACT,SACaR,GAAa,IAAM,CAIxB,IAFAO,EAASP,EAAY,IACrBU,EAAiBtB,EAAUT,EAAO,EAAG4B,CAAM,EACpCG,EAAe,QAClBC,EAAIL,EAAQI,CAAc,EAC1BL,EAAQ,KAAKM,EAAE,IAAI,EACnBD,EAAiBC,EAAE,UAEvB,MAAO,CACH,KAAMN,EACN,UAAW1B,EAAM,SAAS4B,CAAM,CACnC,CACT,KACS,CAID,GAFAC,EAAUR,EAAY,IACtBO,EAAShB,EAAaH,EAAUT,EAAO,EAAG6B,CAAO,CAAC,EAC9CD,EAAS,GACT,MAAM,IAAI,MAAM,qCAAqC,EAEzD,MAAMK,EAAcJ,EAAUD,EAC9B,GAAIK,EAAcjC,EAAM,OACpB,MAAM,IAAI,MAAM,mDAAmD,EAGvE,IADA+B,EAAiBtB,EAAUT,EAAO6B,EAASI,CAAW,EAC/CF,EAAe,QAClBC,EAAIL,EAAQI,CAAc,EAC1BL,EAAQ,KAAKM,EAAE,IAAI,EACnBD,EAAiBC,EAAE,UAEvB,MAAO,CACH,KAAMN,EACN,UAAW1B,EAAM,SAASiC,CAAW,CACxC,CACT,CACA,CACA,MAAMC,EAAc,MAAM,KAAK,CAAE,OAAQ,GAAK,EAAE,CAACC,EAAIhC,IAAMA,EAAE,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EAC1F,SAASY,EAAWqB,EAAQ,CAExB,IAAIC,EAAM,GACV,QAASlC,EAAI,EAAGA,EAAIiC,EAAO,OAAQjC,IAC/BkC,GAAOH,EAAYE,EAAOjC,CAAC,CAAC,EAEhC,OAAOkC,CACX,CACA,SAASvB,EAAawB,EAAS,CAC3B,MAAMC,EAAO,OAAO,SAASD,EAAS,EAAE,EACxC,GAAI,OAAO,MAAMC,CAAI,EACjB,MAAM,IAAI,MAAM,uBAAuB,EAC3C,OAAOA,CACX,CAEA,SAASjB,EAAWe,EAAK,CACrB,GAAI,OAAOA,GAAQ,SACf,MAAM,IAAI,UAAU,oCAAsC,OAAOA,CAAG,EAExE,GAAIA,EAAI,OAAS,EACb,MAAM,IAAI,MAAM,2CAA2C,EAC/D,MAAMG,EAAQ,IAAI,WAAWH,EAAI,OAAS,CAAC,EAC3C,QAASlC,EAAI,EAAGA,EAAIqC,EAAM,OAAQrC,IAAK,CACnC,MAAMsC,EAAItC,EAAI,EACdqC,EAAMrC,CAAC,EAAIW,EAAauB,EAAI,MAAMI,EAAGA,EAAI,CAAC,CAAC,CACnD,CACI,OAAOD,CACX,CAEA,SAASnC,KAAeqC,EAAQ,CAC5B,GAAIA,EAAO,SAAW,EAClB,OAAOA,EAAO,CAAC,EACnB,MAAMd,EAASc,EAAO,OAAO,CAACC,EAAGC,IAAQD,EAAIC,EAAI,OAAQ,CAAC,EACpDC,EAAS,IAAI,WAAWjB,CAAM,EACpC,QAASzB,EAAI,EAAG2C,EAAM,EAAG3C,EAAIuC,EAAO,OAAQvC,IAAK,CAC7C,MAAMyC,EAAMF,EAAOvC,CAAC,EACpB0C,EAAO,IAAID,EAAKE,CAAG,EACnBA,GAAOF,EAAI,MACnB,CACI,OAAOC,CACX,CACA,SAASE,EAAYC,EAAK,CACtB,OAAO,IAAI,YAAW,EAAG,OAAOA,CAAG,CACvC,CAEA,SAAS7B,EAAY8B,EAAS,CAC1B,GAAIA,EAAU,EACV,MAAM,IAAI,MAAM,gDAAgD,EAEpE,MAAMZ,EAAMY,EAAQ,SAAS,EAAE,EAC/B,OAAOZ,EAAI,OAAS,EAAI,IAAIA,CAAG,GAAKA,CACxC,CAEA,SAASa,EAAUP,EAAG,CAClB,OAAOA,EAAE,OAAS,EAAI,IAAIA,CAAC,GAAKA,CACpC,CAEA,SAASQ,EAAcC,EAAK,CACxB,OAAOA,EAAI,QAAU,GAAKA,EAAI,CAAC,IAAM,KAAOA,EAAI,CAAC,IAAM,GAC3D,CAEA,SAASC,EAAeD,EAAK,CACzB,OAAI,OAAOA,GAAQ,SACRA,EAEJD,EAAcC,CAAG,EAAIA,EAAI,MAAM,CAAC,EAAIA,CAC/C,CAEA,SAAS5C,EAAQK,EAAG,CAChB,GAAIA,aAAa,WACb,OAAOA,EAEX,GAAI,OAAOA,GAAM,SACb,OAAIsC,EAActC,CAAC,EACRS,EAAW4B,EAAUG,EAAexC,CAAC,CAAC,CAAC,EAE3CkC,EAAYlC,CAAC,EAExB,GAAI,OAAOA,GAAM,UAAY,OAAOA,GAAM,SACtC,OAAKA,EAGES,EAAWH,EAAYN,CAAC,CAAC,EAFrB,WAAW,KAAK,EAAE,EAIjC,GAAIA,GAAM,KACN,OAAO,WAAW,KAAK,EAAE,EAE7B,MAAM,IAAI,MAAM,sCAAwC,OAAOA,CAAC,CACpE,CACO,MAAMyC,EAAQ,CACjB,WAAAvC,EACA,YAAAV,EACA,WAAAiB,EACA,YAAAyB,CACJ,EACaQ,EAAM,CAAE,OAAAxD,EAAQ,OAAAwB,CAAQ,EClP/BiC,EAAsBC,GAAuC,CAC7D,GAAA,CACE,GAAA,CAACA,GAAQ,MAAMA,CAAI,EAAS,MAAA,IAAI,MAAM,6BAA6B,EAEnE,GAAAA,GAAQ,KAAQA,EAAO,IAClB,MAAA,6CACL,GAAAA,GAAQ,KAAQA,EAAO,IAClB,MAAA,6CACL,GAAAA,GAAQ,KAAQA,EAAO,IAClB,MAAA,6CACL,GAAAA,GAAQ,KAAQA,EAAO,IAClB,MAAA,6CACL,GAAAA,GAAQ,KAAQA,EAAO,IAClB,MAAA,6CACJ,MAAM,IAAI,MAAM,oDAAoD,QAClEC,EAAO,CACN,QAAA,MAAM,SAAUA,CAAK,CAAA,CAEjC,EAEMC,EAAgCC,GAAqC,CACzE,MAAMhB,EAAM,CAAC,EACb,UAAWiB,KAASD,EACdhB,EAAA,KAAK,KAAOU,EAAM,WAAWC,EAAI,OAAOM,CAAK,CAAC,CAAC,EAG9C,MADW,KAAOP,EAAM,WAAWC,EAAI,OAAOX,CAAG,CAAC,CAE3D,QA+Bc,CACZ,mBAAAY,EACA,UApBgB,CAChBC,EACAK,EACAF,IAC4B,CACxB,GAAA,CACF,GAAI,CAACE,GAAW,CAACF,GAAUA,EAAO,SAAW,EACrC,MAAA,IAAI,MAAM,uBAAuB,EAClC,MAAA,CACL,KAAME,EACN,GAAIN,EAAmBC,CAAI,EAC3B,KAAME,EAAS,CAACF,EAAM,GAAGG,CAAM,CAAC,CAClC,QACOF,EAAO,CACN,QAAA,MAAM,SAAUA,CAAK,CAAA,CAEjC,CAKA","x_google_ignoreList":[0]}