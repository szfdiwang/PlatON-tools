{"version":3,"file":"platon-tools.es.js","sources":["../node_modules/@ethereumjs/rlp/dist/esm/index.js","../src/index.ts"],"sourcesContent":["/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/\nexport function encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        let outputLength = 0;\n        for (let i = 0; i < input.length; i++) {\n            const encoded = encode(input[i]);\n            output.push(encoded);\n            outputLength += encoded.length;\n        }\n        return concatBytes(encodeLength(outputLength, 192), ...output);\n    }\n    const inputBuf = toBytes(input);\n    if (inputBuf.length === 1 && inputBuf[0] < 128) {\n        return inputBuf;\n    }\n    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);\n}\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */\nfunction safeSlice(input, start, end) {\n    if (end > input.length) {\n        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');\n    }\n    return input.slice(start, end);\n}\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */\nfunction decodeLength(v) {\n    if (v[0] === 0) {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseHexByte(bytesToHex(v));\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Uint8Array.from([len + offset]);\n    }\n    const hexLength = numberToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = numberToHex(offset + 55 + lLength);\n    return Uint8Array.from(hexToBytes(firstByte + hexLength));\n}\nexport function decode(input, stream = false) {\n    if (typeof input === 'undefined' || input === null || input.length === 0) {\n        return Uint8Array.from([]);\n    }\n    const inputBytes = toBytes(input);\n    const decoded = _decode(inputBytes);\n    if (stream) {\n        return {\n            data: decoded.data,\n            remainder: decoded.remainder.slice(),\n        };\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error('invalid RLP: remainder must be zero');\n    }\n    return decoded.data;\n}\n/** Decode an input with RLP */\nfunction _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.subarray(1),\n        };\n    }\n    else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Uint8Array.from([]);\n        }\n        else {\n            data = safeSlice(input, 1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');\n        }\n        return {\n            data,\n            remainder: input.subarray(length),\n        };\n    }\n    else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error('invalid RLP: not enough bytes for string length');\n        }\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length <= 55) {\n            throw new Error('invalid RLP: expected string length to be greater than 55');\n        }\n        data = safeSlice(input, llength, length + llength);\n        return {\n            data,\n            remainder: input.subarray(length + llength),\n        };\n    }\n    else if (firstByte <= 0xf7) {\n        // a list between 0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = safeSlice(input, 1, length);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.subarray(length),\n        };\n    }\n    else {\n        // a list over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length < 56) {\n            throw new Error('invalid RLP: encoded list too short');\n        }\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error('invalid RLP: total length is larger than the data');\n        }\n        innerRemainder = safeSlice(input, llength, totalLength);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.subarray(totalLength),\n        };\n    }\n}\nconst cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    // Pre-caching chars with `cachedHexes` speeds this up 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += cachedHexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction parseHexByte(hexByte) {\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte))\n        throw new Error('Invalid byte sequence');\n    return byte;\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = parseHexByte(hex.slice(j, j + 2));\n    }\n    return array;\n}\n/** Concatenates two Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction utf8ToBytes(utf) {\n    return new TextEncoder().encode(utf);\n}\n/** Transform an integer into its hexadecimal value */\nfunction numberToHex(integer) {\n    if (integer < 0) {\n        throw new Error('Invalid integer as argument, must be unsigned!');\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n    return str.length >= 2 && str[0] === '0' && str[1] === 'x';\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform anything into a Uint8Array */\nfunction toBytes(v) {\n    if (v instanceof Uint8Array) {\n        return v;\n    }\n    if (typeof v === 'string') {\n        if (isHexPrefixed(v)) {\n            return hexToBytes(padToEven(stripHexPrefix(v)));\n        }\n        return utf8ToBytes(v);\n    }\n    if (typeof v === 'number' || typeof v === 'bigint') {\n        if (!v) {\n            return Uint8Array.from([]);\n        }\n        return hexToBytes(numberToHex(v));\n    }\n    if (v === null || v === undefined) {\n        return Uint8Array.from([]);\n    }\n    throw new Error('toBytes: received unsupported type ' + typeof v);\n}\nexport const utils = {\n    bytesToHex,\n    concatBytes,\n    hexToBytes,\n    utf8ToBytes,\n};\nexport const RLP = { encode, decode };\n//# sourceMappingURL=index.js.map","import { RLP, utils } from \"@ethereumjs/rlp\";\r\nimport {\r\n  ParamsForCode,\r\n  ParamsForTx,\r\n  CodeType,\r\n  GetDataParams,\r\n  MethodParams,\r\n} from \"./types\";\r\n/**\r\n * @param code number function type E.g. 1004 委托, 1005 解委托\r\n * @returns build-in contract address\r\n */\r\nconst getContractAddress = (code: CodeType): string | undefined => {\r\n  try {\r\n    if (!code || isNaN(code)) throw new Error(\"Please check the parameters\");\r\n\r\n    if (code >= 1000 && code < 2000)\r\n      return \"0x1000000000000000000000000000000000000002\";\r\n    if (code >= 2000 && code < 3000)\r\n      return \"0x1000000000000000000000000000000000000005\";\r\n    if (code >= 3000 && code < 4000)\r\n      return \"0x1000000000000000000000000000000000000004\";\r\n    if (code >= 4000 && code < 5000)\r\n      return \"0x1000000000000000000000000000000000000001\";\r\n    if (code >= 5000 && code < 6000)\r\n      return \"0x1000000000000000000000000000000000000006\";\r\n    else throw new Error(\"The contract corresponding to code cannot be found\");\r\n  } catch (error) {\r\n    console.error(\"error:\", error);\r\n  }\r\n};\r\n\r\nconst _getData = <T extends CodeType>(params: GetDataParams<T>): string => {\r\n  const arr = [];\r\n  for (const param of params) {\r\n    arr.push(\"0x\" + utils.bytesToHex(RLP.encode(param)));\r\n  }\r\n  const rlpedData = \"0x\" + utils.bytesToHex(RLP.encode(arr));\r\n  return rlpedData;\r\n};\r\n\r\n/**\r\n *\r\n * @param code string function type\r\n * @param address string user wallet address\r\n * @param params array E.g. [type, nodeId, amount]\r\n * type uint16(2bytes)\t表示使用账户自由金额还是账户的锁仓金额做委托，0: 自由金额； 1: 锁仓金额；2: 优先使用锁仓余额，锁仓余额不足则剩下的部分使用自由金额\r\n * nodeId nodeId\t64bytes\t被质押的节点的 NodeId\r\n * amount big.Int(bytes)\t委托的金额(按照最小单位算，1LAT = 10^18 von)\r\n * @returns ParamsForTx | undefined\r\n */\r\n\r\nconst getParams = <T extends CodeType>(\r\n  code: T,\r\n  address: string,\r\n  params: ParamsForCode<T>\r\n): ParamsForTx | undefined => {\r\n  try {\r\n    if (!address || !params || params.length === 0)\r\n      throw new Error(\"Function params error\");\r\n    return {\r\n      from: address,\r\n      to: getContractAddress(code),\r\n      data: _getData([code, ...params]),\r\n    };\r\n  } catch (error) {\r\n    console.error(\"error:\", error);\r\n  }\r\n};\r\n\r\nconst Tools = {\r\n  getContractAddress,\r\n  getParams,\r\n};\r\n\r\nexport default Tools;\r\n"],"names":["encode","input","output","outputLength","i","encoded","concatBytes","encodeLength","inputBuf","toBytes","safeSlice","start","end","decodeLength","v","parseHexByte","bytesToHex","len","offset","hexLength","numberToHex","lLength","firstByte","hexToBytes","decode","stream","inputBytes","decoded","_decode","length","llength","data","innerRemainder","d","totalLength","cachedHexes","_v","uint8a","hex","hexByte","byte","array","j","arrays","a","arr","result","pad","utf8ToBytes","utf","integer","padToEven","isHexPrefixed","str","stripHexPrefix","utils","RLP","getContractAddress","code","error","_getData","params","param","getParams","address","Tools"],"mappings":"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","x_google_ignoreList":[0]}